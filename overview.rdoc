= Overview

This page describes the various components that form a Roby application. It is
meant to be an "entry point" for people to understand what classes are there
for. This describes the software architecture of the upcoming v0.8.

= Implementation of the plan execution mechanism

The plan representation and the plan execution is handled by three objects:
* a Plan object which manages the various tasks and events which describe the
  system's plan.
* an ExecutionEngine object which manipulates that Plan object. It propagates
  events according to a set of "initial event", a set of events that are
  considered to be emitted. They can be generated by external communication (for
  instance from external robotic control frameworks like GenoM or Orocos), or
  internally by the scheduler object (see ExecutionEngine#scheduler). The engine
  is also responsible for reaction to errors and for the garbage collection
  mechanism, through which tasks that are useless for the system's goals are
  automatically killed and removed.
* a DecisionControl object which handles runtime error resolution (i.e.
  situations which require choosing between multiple course of action).

= A Roby Controller

One Application instance is created per Roby controller. This class sets up the
various central objects (Plan, ExecutionEngine and DecisionControl) and starts
the execution engine.

= Plan representation and modifications to plans

== Direct modification of plans
In Roby, plans are made of tasks and events. See {my
papers}[link:files/doc/papers_rdoc.html] for an in-depth description of the
model.

On the one hand, Roby::EventGenerator instances represent the plan's
/possible/ events. This is by contrast to the Roby::Event class, whose instances
represent the /actual events/ (i.e. an Event instance represent an event which
has already been emitted while an EventGenerator instance represents a source
of events, therefore a kind of events that could possibly be emitted.

On the other hand, instances of Roby::Task represent the activities of the
system. Special subclasses of Roby::EventGenerator and Roby::Event is used in
tasks, to represent some particular properties of task's events:
Roby::TaskEventGenerator and Roby::TaskEvent.

Roby::EventGenerator instances can be linked to each other through the use of
/event relations/, as Roby::Task can be through the use of /task relations/.
Task and event relations are defined in the Roby::EventStructure and
Roby::TaskStructure relation spaces (Roby::RelationSpace), through the use of
Roby::RelationSpace#relation. Each relation object (for instance
Roby::EventStructure::Signal or Roby::TaskStructure::Hierarchy) is an instance
of the Roby::RelationGraph class. Tasks and events, to be managed by those
relations, include the Roby::DirectedRelationSupport mixin to provide the basic
management tools needed by the RelationGraph instances. Moreover, all relations
extend the corresponding relation vertices by custom relation-modification
methods (like #add_signal, #each_parent or #parents). See RelationSpace#relation
for details.

Modifying the plan therefore boils down to adding and removing relations between
objects of the same type. To ease the plan management process, some synthetic
operations are defined on Roby::Plan:
* the *replacement* operation: Roby::Plan#replace_task(a, b) and
  Roby::Plan#replace(a, b) if possible.
* the +respawning+ operation: a given task is replaced by a new task of the same
  kind and with the same parameters. This is used mainly to workaround a
  "fragile" task which crashed spuriously.

== Modification using transaction objects
