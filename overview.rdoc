== Overview

This page describes the various components that form a Roby application. It is
meant to be an "entry point" for people to understand what classes are there
for. This describes the software architecture of the upcoming v0.8.

= Implementation of the plan execution mechanism

The plan representation and the plan execution is handled by three objects:
* a Plan object which manages the various tasks and events which describe the
  system's plan.
* an ExecutionEngine object which manipulates that Plan object. It propagates
  events according to a set of "initial event", a set of events that are
  considered to be emitted. They can be generated by external communication (for
  instance from external robotic control frameworks like GenoM or Orocos), or
  internally by the scheduler object (see ExecutionEngine#scheduler). The engine
  is also responsible for reaction to errors and for the garbage collection
  mechanism, through which tasks that are useless for the system's goals are
  automatically killed and removed.
* a DecisionControl object which handles runtime error resolution (i.e.
  situations which require choosing between multiple course of action).

The three "main" instances of these objects -- i.e. the ones that are supposed
to interact directly with the underlying robotic system -- are available
through the Roby.plan, Roby.engine and Roby.control attributes. These
attributes are set up at application start by Roby::Application#run.

== Life and death of a Roby Controller

One Roby::Application instance is created per Roby controller. This class sets
up the various central objects (Plan, ExecutionEngine and DecisionControl),
starts the execution engine and loads the relevant configuration files.

A Roby controller offers a DRb main server which is a Roby::Interface instance.
The best way to interact through this channel is to use a Roby::RemoteInterface
instance, which handles some custom marshalling/demarshalling of data, offering
a transparent interface to the remote controller. The <tt>scripts/shell</tt>
default script sets this up properly.

A Roby controller will shut down in the following conditions:
* CTRL+C is hit in the controller's main terminal
* the 'exit' command is sent through the remote shell
* a framework exception is detected, meaning an exception which is not part of
  the plan-based error recovery mechanism (everything but event commands, event
  handlers and polling blocks).

== Plan representation and modifications to plans

=== Direct modification of plans
In Roby, plans are made of tasks and events. See {my
papers}[link:files/doc/papers_rdoc.html] for an in-depth description of the
model.

On the one hand, Roby::EventGenerator instances represent the plan's _possible_
events. This is by contrast to the Roby::Event class, whose instances represent
the <em>actual events</em>. In other words, an Event instance represent an
event which has already been emitted while an EventGenerator instance
represents a source of events, therefore a kind of events that could possibly
be emitted.

On the other hand, instances of Roby::Task represent the activities of the
system. Special subclasses of Roby::EventGenerator and Roby::Event are used in
tasks, to represent some particular properties of task's events:
Roby::TaskEventGenerator and Roby::TaskEvent.

Roby::EventGenerator instances can be linked to each other through the use of
<em>event relations</em>, as Roby::Task can be linked through the use of <em>task relations</em>.
Task and event relations are defined in the Roby::EventStructure and
Roby::TaskStructure relation spaces (Roby::RelationSpace instances), through the use of
Roby::RelationSpace#relation. Each relation object (for instance
Roby::EventStructure::Signal or Roby::TaskStructure::Hierarchy) is an instance
of the Roby::RelationGraph class. Tasks and events, to be managed by those
relations, include the Roby::DirectedRelationSupport mixin to provide the basic
management tools needed by the RelationGraph instances. Moreover, all relations
extend the corresponding relation vertices by custom relation-modification
methods (like #add_signal, #each_parent or #parents). See RelationSpace#relation
for details.

Modifying the plan therefore boils down to adding and removing relations between
objects of the same type. To ease the plan management process, some synthetic
operations are defined on Roby::Plan:
* the _replacement_ operation: Roby::Plan#replace_task and
  Roby::Plan#replace. #replace_task(a, b) will replace +a+ by +b+ in the plan.
  It means that the operators will add to +b+ all the children and parents of +a+
  in all relations, and do the same with +b+ and +a+'s events. Moreover, it will
  remove them from +a+. #replace(a, b) will do the same, but constraining itself
  to the _parents_ of +b+ and +b+'s events. It therefore replaces +a+ and its
  generated subplan (i.e. +a+ and all children of +a+) by +b+ and its subplan.
* the _respawning_ operation: a given task is replaced by a new task of the same
  kind and with the same parameters. This is used mainly to workaround a
  "fragile" task which crashed spuriously.

