#! /usr/bin/env ruby
require 'roby'
require 'optparse'

def usage
    STDERR.puts <<-EOU
roby-log mode [options]
where the following modes are accepted:
    list-servers    lists the log servers available
    upgrade-format  upgrades an event log from an old format to the current one
    rebuild-index   rebuilds the index file for the given event log
    stats	    displays statistics about the given event log
    decode	    show the content of the log file in raw format
    help	    this help message

Call roby-log mode --help for more information about each mode
    EOU
end

STDOUT.sync = true

SERVER_LIST_TIMEOUT = 5
SERVER_LIST_POLL = 0.1
case mode = ARGV.shift
when "upgrade-format"
    require 'roby/log/upgrade'
    Roby::Log::Upgrade.to_new_format(ARGV[0])
    exit(0)

when "rebuild-index"
    require 'roby/log/file'

    Roby::Log::Logfile.open(ARGV[0]) do |logfile|
	logfile.rebuild_index
    end
    exit(0)

when "stats"
    require 'roby/droby/logfile/reader'
    require 'roby/droby/logfile/timings'

    filename = if ARGV[0] == "--csv"
		   do_csv = true
		   ARGV[1]
               elsif ARGV[0] == "--help"
                   puts "roby-log stats [--csv]"
                   puts "  displays statistics about the execution timings"
                   puts "  if the --csv option is given, a table with all"
                   puts "  the timings is output on stdout instead"
                   exit(0)
               else
		   ARGV[0]
	       end
    io = Roby::DRoby::Logfile::Reader.open(filename)
    index = io.index

    cycle_count = index.size

    if cycle_count == 0
        puts "empty log file"
        exit 0
    end

    timespan    = index.range
    puts "#{cycle_count} cycles between #{timespan.first.to_hms} and #{timespan.last.to_hms}"
    cpu_time = index.inject(0) { |old, info| old + info[:cpu_time] } / 1000
    real_time = timespan.last - timespan.first
    ratio = cpu_time / real_time
    puts "Time: %.2fs CPU / %.2fs real (%i%% CPU use)" % [cpu_time, real_time, ratio * 100]

    if index.first.has_key?(:event_count)
	min, max = nil
	event_count = index.inject(0) do |total, cycle_info|
	    count = cycle_info[:event_count]
	    min = count if !min || min > count
	    max = count if !max || max < count
	    total + count
	end
	puts "#{event_count} events, #{event_count / cycle_count} events/cycle (min: #{min}, max: #{max})"
    else
	puts "event count unavailable, please rebuild the index"
    end

    timings = Roby::DRoby::Logfile::Timings.new(index)
    if do_csv
	timings.display(false)
    else
	timings.stats
    end
    exit(0)

when "decode"
    require 'roby/droby/logfile/reader'
    require 'roby/droby/plan_rebuilder'

    replay = false
    replay_debug = false
    opts = OptionParser.new do |opt|
        opt.on("--replay[=MODE]", "replay the log stream into a plan, mainly useful to debug issues with the plan rebuilder. If MODE is debug, shows extensive debug information") do |mode|
            replay = true
            replay_debug = (mode == 'debug')
        end
    end
    filename = opts.parse(ARGV)
    if filename.size != 1
        puts opts
        exit 1
    end

    stream = Roby::DRoby::Logfile::Reader.open(filename.first)
    if replay
        rebuilder = Roby::DRoby::PlanRebuilder.new
    end
    begin
    while data = stream.load_one_cycle
        data.each_slice(4) do |m, sec, usec, args|
            header = "#{Time.at(sec, usec)} #{m} "
            puts "#{header} #{args.map(&:to_s).join("  ")}"
            header = " " * header.size
            if replay
                begin
                    rebuilder.process_one_event(m, sec, usec, args)
                    if replay_debug
                        if m == :merged_plan
                            puts "Merged plan"
                            plan = args[1]
                            puts "  #{plan.known_tasks.size} tasks: #{plan.known_tasks.map { |id, _| id.to_s }.join(", ")}"
                            puts "  #{plan.task_events.size} task events: #{plan.task_events.map { |id, _| id.to_s }.join(", ")}"
                            puts "  #{plan.free_events.size} events: #{plan.free_events.map { |id, _| id.to_s }.join(", ")}"
                        end
                        pp rebuilder
                    end
                rescue Roby::DRoby::UnknownSibling
                    # Add some more debugging information
                    pp rebuilder
                    raise
                end
            end
        end
        if replay
            rebuilder.clear_integrated
        end
    end
    rescue Exception => e
        pp e
        raise
    end
    exit(0)

when 'repair'
    require 'roby/droby/logfile/reader'
    opts = OptionParser.new
    filename, _ = opts.parse(ARGV)
    event_io = File.open(filename)
    logfile = Roby::DRoby::Logfile::Reader.new(event_io)
    while !logfile.eof?
        current_pos = logfile.tell
        puts current_pos
        begin logfile.load_one_cycle
        rescue Roby::DRoby::Logfile::TruncatedFileError
            puts "last chunk(s) in the file seem to have only been partially written, truncating at #{current_pos}"
            FileUtils.cp filename.first, "#{filename}.broken"
            event_io.truncate(current_pos)
            break
        end
    end
    exit 0
    
when "help"
    usage
    exit(0)

else
    STDERR.puts "no such mode of operation #{mode}"
    usage
    exit(1)
end

