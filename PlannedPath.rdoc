== Planning and following a path
We'll now use a (slightly) more complex system to make our robot move. The robot
will now have a goal, as a X/Y point. It will plan a path to it, and then
execute that path.

There will be three different tasks:
* the +MoveTo+ task does nothing: it will simply express the current goal of the
  robot, and holds the path data
    class MoveTo < Roby::Task
        terminates
	# The movement goal as [x, y]
        arguments :goal
	# The generated path
	def path; data end
    end

* the +ComputePath+ task generates the path on behalf of a +MoveTo+. When
  successful, it updates the +data+ attribute of the movement it is planning

    class ComputePath < Roby::Task
      terminates

      # The maximum speed limit
      arguments :max_speed
      # The distance at which we consider that we have reached the goal
      arguments :threshold

      <code: see below>
    end

* the +TrackPath+ takes the path generated and follows it
    class TrackPath < Roby::Task
      terminates

      # The task holding the path data
      arguments :path
      # The current waypoint, as [x, y]
      def waypoint; path[waypoint_index] end
      # The index of the current waypoint
      attr_reader :waypoint_index

      <code: see below>
    end

=== Building the movement plan
Let's add a +move_to+ action to our robot. Add the following method definition
to the MainPlanner class definition:

  method(:move_to) do
    move = MoveTo.new(:goal => arguments[:goal])
    move.realized_by(compute = ComputePath.new)
    move.realized_by(track = TrackPath.new)

    move.on :start, compute, :start
    compute.on :success, track, :start
    track.forward :success, move, :success

    move
  end

The first part creates the <em>task structure</em>, which expresses the
relationships of the different tasks of the plan. By linking the +compute+ and
+track+ tasks with +move+ using the +realized_by+ relation, we express that the
+move+ needs the other two tasks to finish successfully.

The second part creates the <em>event structure</em>, which expresses how the
plan should respond to events. In our case, we say that the path should be built
when the movement starts, that the tracking starts when the computation is
successful and that the movement is successfully finished when the tracking has
successfully finished. Note that, thanks to the +realized_by+ relation, +move+
will fail if +track+ fails. We therefore do not have to make sure that the
+move+ task's +failed+ event is emitted if +track+ failed.

Another way to write the method would be to do
  move    = MoveTo.new(:goal => arguments[:goal])
  compute = ComputePath.new
  track   = TrackPath.new

  (compute + track).to_task(move)

The <tt>compute + track</tt> statement builds a <b>task sequence</b> through a
task of class Roby::Sequence. This sequence is then transferred as child of the
+move+ task using Roby::Sequence#to_task

=== Implementation of ComputePath and TrackPath

---
vim: tw=80
