---
title: Task Hierarchies
sort_info: 500
--- pipeline:tags,markdown

What have we seen until now ?
* events and signals: a way to represent how the execution should proceed: the
  _execution flow_.
* tasks: how events can be aggregated into a representation of long-running
  processes

A common pattern in supervision system is to represent the _links_ between the
tasks. In Roby, this is achieved through **task relations**. This page presents
the most important of them: the hierarchy relation.

Semantics of task hierarchies
-----------------------------
The goal of that relation is to represent the hard dependencies between tasks.
I.e. to say "task A needs results from task B to perform its duty" or "task A
needs task B to run to perform its duty". The idea behind such a relation is to
be able to create a "library" of tasks that perform simple actions (usually
implemented in a functional layer external to Roby itself), and then to be able
**aggregate** them into more complex actions simply by building plans.

Adding dependencies between tasks
---------------------------------

The code in that section is not meant to be tried out, but to support the
explanations. A proper controller, that uses these principles, is shown in the
following sections.
{.warning}

Let's assume our robot's functional layer offers two services:
* it has a way to compute a path from A to B (path planning)
* it has a way to execute that path once its computed

What we want here is to build the plan that represents a _movement_ from the
current robot's position to a goal position.  That aggregate action will
naturally be represented by a MoveTo task that takes one 'goal' argument. In
Roby, it would look like this:

{coderay:: ruby}
class MoveTo < Roby::Task
  argument :goal
end
{coderay}

So, now, we would have two options:
* either call the functional layer directly from the MoveTo task
* or integrate both services independently (in two different tasks) and then
  aggregate their functionality through the plan.

In Roby, we would usually use the second method, as it promotes reusability. The
plan would therefore have to represent the following:

    To do a MoveTo from point A to point B
      => first the robot must successfully compute its 
         path between those two points
      => then it must successfully execute that path

Assuming that we have the ComputePath and ExecutePath task models to represent
our functional layer's services, and that the target point is represented by the
variable 'p', this can be translated as a plan into:

    The successful execution of MoveTo(:goal => a) depends on
      the successful execution of ComputePath(:goal => a)
      followed by the successful execution of ExecutePath

Finally, that plan would be generated with the following code.

{coderay:: ruby}
 move    = MoveTo.new :goal => a
 compute = ComputePath.new :goal => a
 execute = ExecutePath.new

 # The movement depends on the successful execution of both the computation and
 # execution of the path
 move.depends_on compute
 move.depends_on execute
 # Execution should start when computation has finished successfully
 compute.signal :success, execute, :start
 # Computation should start when the movement starts
 move.signal :start, compute, :start
 # The movement has successfully finished when the execution has successfully
 # finished
 execute.forward :success, move, :success
{coderay}

A controller using task hierarchies
-----------------------------------

What do we need to get a proper controller implementing this ?
* first we need to define the three task models described above
* then we need to define the planning method that will create the necessary
  plan.

The only thing that still needs to be defined is how to transfer the path from
the ComputePath task to the ExecutePath task. In general, such an endeavour is
done in Roby through task objects. Indeed, each task object has a 'data'
attribute that allows a task to hold arbitrary data.

Note that you can use normal Ruby attributes for the same purpose. The 'data'
attribute has two added functionalities: (i) it is shared in multi-robot
contexts, and (ii) an 'updated\_data' event is emitted when it is changed. If you
use neither of these functionalities, you can use normal attributes.
{.remark}

Given that the actual actions are performed by ComputePath and ExecutePath, the
definition of the MoveTo task is actually quite simple:

{coderay:: ruby}
class MoveTo < Roby::Task
  terminates

  # The movement goal
  argument :goal
  # The generated path
  def path; data end
end
{coderay}

TODO

{coderay:: ruby}
require 'roby/thread_task'
class ComputePath < Roby::ThreadTask
  # Where we should store the path when computed
  argument :path_holder
  # The movement goal
  argument :goal

  # The robot position at which we started planning # the path
  attr_reader :start_point

  # Initialize start_point and call ThreadTask's start command
  event :start do |context|
    @start_point = State.pos.dup
    super
  end

  # Implementation of the computation thread
  implementation do
    path      = [start_point]
    max_speed = 1
    while goal.distance(path.last) > max_speed
      u = goal - path.last
      u /= u.length / max_speed
      path << path.last + u
    end
    path << goal

    Robot.info "#{path.size} points between #{start_point} and #{goal}"
    path
  end

  on :success do |ev|
    path_holder.data = ev.context
  end
end
{coderay}

Finally, TrackPath takes the path generated and follows it. Open
tasks/track\_path.rb and add the following:

{coderay:: ruby}
class TrackPath < Roby::Task
  terminates

  # The task holding the path data
  argument :path_task

  # The current waypoint
  def current_waypoint; path_task.data[@waypoint_index] end

  poll do
    @waypoint_index ||= 0
    State.pos = current_waypoint
    @waypoint_index += 1
    if @waypoint_index == path_task.data.size
      emit :success
    end

    Robot.info "moved to #{current_waypoint}"
  end
end
{coderay}

