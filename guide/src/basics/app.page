---
title: First App
sort_info: 300
--- pipeline:tags,markdown,blocks

A first Roby application
========================

Creation
--------

Go into a *regular shell* (i.e. not IRB) and create a new directory. That
directory will become your first Roby application by running "roby init":

    $ mkdir first_app
    $ cd first_app
    $ roby init
    creating tasks/
    creating tasks/.gitattributes
    creating scripts/
    creating scripts/test
    creating scripts/shell
    creating scripts/server
    creating scripts/run
    creating scripts/results
    creating scripts/replay
    creating scripts/generate/
    creating scripts/generate/bookmarks
    creating scripts/distributed
    creating planners/
    creating planners/main.rb
    creating data/
    creating data/.gitattributes
    creating controllers/
    creating controllers/.gitattributes
    creating config/
    creating config/roby.yml
    creating config/init.rb
    creating config/app.yml
    creating Rakefile
    creating README.txt

There's a lot of stuff created, but don't worry we'll learn what this is all
about later on. Right now, we're only interested in two small parts of it:
* the tasks/ directory, which is where task models (task classes) should be
  defined
* the robot's controller (controllers/FirstRobot.rb). Whatever code is put there
  is executed when the application is started.

The goForward robot
-------------------
As an introduction, we will create a simulated robot controller which makes the
robot go forward at constant speed.

First, let's create the files specific to this robot
    $ roby robot goForward
    creating planners/goForward/
    creating planners/goForward/main.rb
    creating tasks/goForward/
    creating tasks/goForward/.gitattributes
    creating controllers/goForward.rb
    creating config/goForward.rb

Let's define the task model. Edit tasks/go\_forward.rb and add

{coderay:: ruby}
 class GoForward < Roby::Task
   # The GoForward task needs the robot speed to be specified
   arguments :speed

   # Block called at every execution loop. It simulates the
   # robot moving at the specified speed.
   poll do
     State.pos.x += speed
   end

   # This task does not need any specific action to stop
   terminates
 end
{coderay}

In the controller file, controllers/goForward.rb, we add the code that
should run at startup:

{coderay:: ruby}
 # Define the original value of x
 State.pos.x = 0

 # Will display the value of x every 1 second
 Roby.every(1) do
   puts State.pos.x
 end

 # Create the task and start moving !
 Roby.plan.insert(go = GoForward.new(:speed => 0.1))
 puts "Going forward at speed #{go.speed}"
 go.start!
{coderay}

You can then start the robot controller with scripts/run and stop it with CTRL+C.

    $ scripts/run goForward
    335705:25:08.324 (goForward) loading controller file /home/doudou/dev/roby-tutorials/controllers/goForward.rb
    Going forward at speed 0.1
    335705:25:08.356 (goForward) done initialization
    0
    0.9
    1.9
    2.9
    335705:25:16.449 (Roby) received interruption request
    335705:25:16.524 (Roby) control quitting. Waiting for 1 tasks to finish (1 tasks still in plan)

Broken down explanation
-----------------------
* the Roby::State object holds all the configuration and state data that
  represents the robot's state. In our case, we initialize the robot's position
  in the controller file, and then update it when the robot moves.

* to understand the meaning of the +poll+ statement, you have to understand
  the idea behind Roby's execution model. Roby relies on a _synchronous_
  execution model, which is basically a two-steps loops (a more detailed
  explanation will come in the following tutorials). This two-steps loops
  is basically:
  1. gather all events that have occured since the last loop
  2. react to those events

  Now, what is the role of +poll+ here ? The block given to +poll+ is executed
  at each execution cycle <i>while the task is running</i>. It can therefore be
  used to break done lengthy computation in small steps, or to monitor an
  external process or thread through polling.

