---
title: Using Plan Display
sort_info: 600
--- pipeline:tags,markdown

What we will see in this page is how to trace the execution flow (the flow of
events), and understand a bit more how the plans you will build are actually
executed by the system. We will re-use the planned\_move planning action we just
built.

Getting a log file
------------------

Plan execution logs are expensive from a CPU point of view, so they are disabled
by default. Enable them back by editing config/app.yml and uncomment
"events: true" around line 23. 

Now, run again the controller

    # scripts/run goForward

and in the shell, do

    >> planned_move! :x => 10, :y => 10
    => MoveTo{goal => Vector3D(x=10.000000,y=10.000000,z=0.000000)}:0x4840c8d8[]
    >>
    !task MoveTo{goal => Vector3D(x=10.000000,y=10.000000,z=0.000000)}:0x4840c8d8[] finished successfully

Finally, let's save the log files for further analysis (otherwise, one could
destroy them by restarting the controller).

    # scripts/result planned_move
    moving /home/doudou/dev/first_app/log to /home/doudou/dev/roby-tutorials/results/20080502-planned_move

"scripts/result" copies all files in "log/" into a subdirectory
of the result dir (by default APP\_DIR/results, but can be changed in
"config/app.yml"). The target directory name is generated following a pattern of
"current\_date-name\_provided\_on\_command\_line".

Displaying the log file
-----------------------
Go in the directory where the results are (see <tt>scripts/results</tt> output).
On my machine, the command would look like this:

    $ cd /home/doudou/dev/roby-tutorials/results/20080502-planned_move
    $ ls
    goForward-events.log
    goForward-index.log

If you look into it, two PathPlan files are present: <tt>PathPlan-events.log</tt> and
"PathPlan-index.log".  The first one includes a trace of everything that
happens in the Roby controller which has been traced. The second one can
actually be generated from data in the first one. It is simply used to speed up
operations.

The data in the event log can be used to display the plan operations in a GUI.
For that, you need to have installed [Ruby/Qt4](http://korundum.rubyforge.org), as
the GUI is written using Qt and Ruby.

To start it, simply do the following in the directory of the log files:

    $ roby-log replay goForward

The following window should appear:

![](log_replay/roby_log_main_window.png)

This window is separated in three:

* the toplevel part ("Data sources") is the list of data sources defined for
  this project. It is for instance possible to have a synchronized display of
  the logs of two different Roby controllers -- for multi-robot setup.
* the second part ("Displays") is the set of displays defined. More about that later.
* the third part ("Play") is the replay controls: play, fast forward, position, ...

Right now, we will be looking at the plan structure and execution trace. The
"Relations" display is designed for that. Let's add one by clicking on the
"Add" button just next to the display type combo. The configuration options
appear (including the data source associated with the display), and a new
window:

![](log_replay/roby_log_relation_window.png)

This display will show two things: the task structure (i.e. how tasks are
related to each other) and the event propagation (i.e. how events call and/or
emit each other). The set of task relations to display has to be selected on
the configuration part of the relation display, including the colors for each
displayed relation. For our purposes, we only need the "Hierarchy" and the
"PlannedBy" relations, so check them in the display configuration, as it is done
one the image above.

Moreover,
* go in the "View" menu of the relation display and uncheck "Hide
  finalized", that will be useful for later.
* go in the "Task labels" and uncheck "Ownership". Ownership is only useful for
  multi-robot plans.

**Very important note** your own display may not look exactly like the ones
displayed here. Some of the features showed here (like threaded planning) are
asynchronous and as such the exact displays depend on the execution timing. Note
that, even though it is the case, the robot _behaviour_ remains unchanged.
{.warning}

Startup of the "planned\_move!" action
---------------------------------------

Let's get to the first task-related events. Click on the 'Step' button until
something appears on the display. It should look like the next image:

![](log_replay/goForward_1.png)

The displays shows two plans (black boxes). The left one is the plan as it is
being executed. The right one is called a _transaction_ and allows to build a
new plan without interfering with the execution. You don't really need to know
how it works, only that it does the job. The task description includes the task
model and the task owners (which is only useful in multi-robot setup). The
_Task labels_ menu allows to customize that.

The left part is a representation of the plan built when the planned\_move!
command is entered in the shell. It consists of a generic task (Roby::Task)
which is planned\_by a Roby::PlanningTask. This is how Roby handles action
requests from the shell: (i) it searches a planner defined for that robot with
the specific action and (ii) generates the plan representing the planning
process _in a separate thread_.

Once that initial plan has been built, the Roby::PlanningTask task has been
started. The various cases of event propagation are represented in different
ways, based on whether or not the event is controlable or contingent, or if it is
called and/or emitted.

![](log_replay/roby_replay_event_representation.png)

A note about propagation representation: it would be useless to represent all
the event propagation from the beginning of the execution to the current point.
The display therefore represents only the propagations that have taken place
_since the last display point_. It means that, if you go forward 10
seconds, it will display 10 seconds worth of propagation. In our case, we
displayed only the first execution cycle and we see that, in this cycle, the
planning task "start" event has been called and emitted.

The MoveTo plan
---------------

Advance again using 'Step' until the display looks like this:

![](log_replay/goForward_2.png)

The MoveTo action has been planned and the executed plan is modified to reflect
that. The MoveTo action itself is then started, and that is propagated to the
ComputePath 'start' event through the signalling relation that was established
in planned\_move.

Next execution step gives us the following:

![](log_replay/goForward_3.png)

ComputePath emitted its "success" event. We see here that the emission of the
"success" event of that task does not mean 'the plan modification has just took
place' but instead that 'it has taken place some time earlier'.

The ComputePath task has also finished generating the path, which is why
ExecutePath is started. Here, the dotted lines between the events
represent a forwarding relation between them, while the plain lines
represent signal relations.

Finally, light grey here represents tasks that have finished with the "success"
event. Tasks whose "failed" event has been emitted are represented in red.

To finish: the garbage collection process
-----------------------------------------

Advance a few steps further, until something more happens. You should see
something like this:

![](log_replay/goForward_5.png)

Here, ExecutePath has finished its execution with success and MoveTo is therefore
finished as well -- per the forwarding relation between those two events. Note
that the tasks are now in a dark grey instead than a light one. 

The mission of the robot, MoveTo, is therefore finished. From the plan
management point of view, it makes keeping a reference to it useless. In the
same way, the tasks that were in the plan for the purpose of fullfilling that
mission are rendered useless as well and can also be removed. The process which
removes those tasks is called the <i>garbage collection process</i> and runs at
the end of the execution cycle.

The general idea is to kill and remove from the plan the tasks that are not
useful for the achievement of the robot's missions. The "important" tasks for
the robot is defined by the set of its missions.  These are added by calling
Plan#add\_mission instead of the Plan#add that we were using until now. Note
that, by calling the action through the shell, #add\_mission has been called
automatically by the framework.

Then, the task relations are used to determine what are the tasks, in the plan,
which are actually useful for those "important" tasks. This is based on the
convention that if a <tt>a=>b</tt> relation exists, then "b" is useful for "a".

The remaining tasks, i.e. the tasks that are not useful, are killed (if possible)
and removed from the plan. When it is done, the task is said to be finalized and
are displayed in dark grey (if they are not hidden in the View menu).

