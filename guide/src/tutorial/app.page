---
title: A First Roby Application
sort_info: 300
---

This page will present another facet of Roby. What we saw until now is how,
in Roby, one can represent the task actions and build plans that describe the
task execution. What we will see here is how Roby tie the different models
together to offer an application environment.

{include_file: {filename: src/basics_shell_header.txt, escape_html: false}}

Creation
--------

Go into a *regular shell* (i.e. not the Ruby shell) and create a new directory.
That directory will become your first Roby application by running "roby init":

    $ mkdir first_app
    $ cd first_app
    $ roby init
    creating tasks/
    creating tasks/.gitattributes
    creating scripts/
    creating scripts/test
    creating scripts/shell
    creating scripts/server
    creating scripts/run
    creating scripts/results
    creating scripts/replay
    creating scripts/generate/
    creating scripts/generate/bookmarks
    creating scripts/distributed
    creating planners/
    creating planners/main.rb
    creating data/
    creating data/.gitattributes
    creating controllers/
    creating controllers/.gitattributes
    creating config/
    creating config/roby.yml
    creating config/init.rb
    creating config/app.yml
    creating Rakefile
    creating README.txt

There's a lot of stuff created, but don't worry we'll learn what this is all
about later on. Right now, we're only interested in two small parts of it:

* the tasks/ directory, which is where task models (task classes) should be
  defined
* the robot's controllers. These files contain the code that is run when the
  application is started.

The goForward robot
-------------------
As an introduction, we will create a simulated robot controller which makes the
robot go forward at constant speed.

First, let's create the files specific to this robot

    $ roby robot goForward
    creating planners/goForward/
    creating planners/goForward/main.rb
    creating tasks/goForward/
    creating tasks/goForward/.gitattributes
    creating controllers/goForward.rb
    creating config/goForward.rb

Let's define the task model. Edit tasks/go\_forward.rb and add

{coderay:: ruby}
 class GoForward < Roby::Task
   # The GoForward task needs the robot speed to be specified
   arguments :speed

   # Block called at every execution loop if the task is running. It simulates
   # the robot moving at the specified speed.
   poll do
     State.pos.x += speed
   end

   # This task does not need any specific action to stop
   terminates
 end
{coderay}

In the controller file, controllers/goForward.rb, we add the code that
should run at startup:

{coderay:: ruby}
 # Define the original value of x
 State.pos.x = 0

 # Will display the value of x every 1 second
 Roby.every(1) do
   puts State.pos.x
 end

 # Create the task and start moving !
 Roby.plan.insert(go = GoForward.new(:speed => 0.1))
 puts "Going forward at speed #{go.speed}"
 go.start!
{coderay}

You can then start the robot controller with scripts/run and stop it with CTRL+C.

    $ scripts/run goForward
    335705:25:08.324 (goForward) loading controller file /home/doudou/dev/roby-tutorials/controllers/goForward.rb
    Going forward at speed 0.1
    335705:25:08.356 (goForward) done initialization
    0
    0.9
    1.9
    2.9
    335705:25:16.449 (Roby) received interruption request
    335705:25:16.524 (Roby) control quitting. Waiting for 1 tasks to finish (1 tasks still in plan)

Broken down explanation
-----------------------
* the Roby::State object holds all the configuration and state data that
  represents the robot's state. In our case, we initialize the robot's position
  in the controller file, and then update it when the robot moves.

* to understand the meaning of the __poll__ statement, you have to understand
  the idea behind Roby's execution model. Roby relies on a _synchronous_
  execution model, which is basically a two-steps loops (a more detailed
  explanation will come later). This two-steps loops is basically:
  1. gather all events that have occured since the last loop
  2. propagate to those events through the signal and forward relations

  In practice, this event loop runs with a fixed period which is by default
  100ms. This period can be changed in the configuration file config/app.yml.

  Now, what is the role of __poll__ here ? The block given to +poll+ is executed
  at each execution cycle _while the task is running_. It can therefore be
  used to _implement_ the actual task functionality (or to check the state of
  external processes, ...)

