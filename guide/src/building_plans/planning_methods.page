---
title: Planning Interface
sort_info: 200
---

As explained in the tutorial, the planning interface is the place where one
builds plans. It is not really "planning" as in "automated planning", but
simply blocks of code that can be called to create plans or modify the running
plan.

This section will describe the capabilities of this interface to __build
plans__. Modifying running plans is a bit of a harder problem, so we keep it
for a different time.

Creating planning methods
-------------------------
Planning methods are created on a subclass of Roby::Planning::Planner. They
are defined using Planner.method with a block. The block does not get any
arguments. Instead, the arguments are accessible through the #arguments
method. The method must return an instance of a roby task. Example:

{coderay:: ruby}
class MainPlanner < Roby::Planning::Planner
  method :move_to do
    target = arguments[:target]
    MoveTo.new(:target => target)
  end
end
{coderay}

To help the inspection of the action interface (i.e. of all actions that the
robot knows about), one can add documentation before the call to Planner.method
using Planner.describe:

{coderay:: ruby}
class MainPlanner < Roby::Planning::Planner
  describe('moves the robot to the target point').
    required_arg('target', 'the target point as a [x, y] pair')
  method :move_to do
    target = arguments[:target]
    MoveTo.new(:target => target)
  end
end
{coderay}

The value returned by Planner.describe is a {rdoc_class: Planner::MethodDescription}.
See the API documentation for an exhaustive list of methods.

Calling planning methods
------------------------
Planning methods can use other planning methods, in which case the return value
is the task returned by the block:

{coderay:: ruby}
class MainPlanner < Roby::Planning::Planner
  describe('follows a set of waypoints').
    required_arg('waypoints',
                 'an array of points as a list of [x, y] pairs')
  method :follow_waypoints do
    sequence = arguments[:waypoints].
	map do |wp|
	    move_to :target => wp
	end
    target = arguments[:waypoints].last
    sequence.inject { |t0, t1| t0 + t1 }.
	to_task(MoveTo.new(target)
  end
end
{coderay}

Moreover, the Robot object allows to use a planning method from any planner
declared in Roby.app.planners (MainPlanner is automatically added there) to add
a new mission to the robot's plan. It is used as the shell interface:

{coderay:: ruby}
Robot.move_to! :target => [10, 20]
{coderay}

The return value from Robot.move_to! is a __placeholder__ for the final task,
which can be integrated in the current plan (i.e. used as parent, child, add
event handlers, add event relations).  This is explained [on the next
page](runtime.html)

