---
title: Planning Interface
sort_info: 200
---

As explained in the tutorial, the planning interface is the place where one
builds plans. It is not really "planning" as in "automated planning", but
simply blocks of code that can be called to create plans or modify the running
plan.

This section will describe the capabilities of this interface to __build
plans__. Modifying running plans is a bit of a harder problem, so we keep it
for a different time.

Creating planning methods
-------------------------
Planning methods are created on a subclass of Roby::Planning::Planner. They
are defined using Planner.method with a block. The block does not get any
arguments. Instead, the arguments are accessible through the #arguments
method. The method must return an instance of a roby task. Example:

{coderay:: ruby}
class MainPlanner < Roby::Planning::Planner
  method :move_to do
    target = arguments[:target]
    MoveTo.new(:target => target)
  end
end
{coderay}

To help the inspection of the action interface (i.e. of all actions that the
robot knows about), one can add documentation before the call to Planner.method
using Planner.describe:

{coderay:: ruby}
class MainPlanner < Roby::Planning::Planner
  describe('moves the robot to the target point').
    required_arg('target', 'the target point as a [x, y] pair')
  method :move_to do
    target = arguments[:target]
    MoveTo.new(:target => target)
  end
end
{coderay}

The value returned by Planner.describe is a {rdoc_class: Planner::MethodDescription}.
See the API documentation for an exhaustive list of methods.

Calling planning methods
------------------------
Planning methods can use other planning methods, in which case the return value
is the task returned by the block:

{coderay:: ruby}
class MainPlanner < Roby::Planning::Planner
  describe('follows a set of waypoints').
    required_arg('waypoints', 'an array of points as a list of [x, y] pairs")
  method :follow_waypoints do
    sequence = arguments[:waypoints].
	map do |wp|
	    move_to :target => wp
	end
    target = arguments[:waypoints].last
    sequence.inject { |t0, t1| t0 + t1 }.
	to_task(MoveTo.new(target)
  end
end
{coderay}

Moreover, the Robot object allows to use a planning method from any planner
declared in Roby.app.planners (MainPlanner is automatically added there) to add
a new mission to the robot's plan. It is used as the shell interface:

{coderay:: ruby}
Robot.move_to! :target => [10, 20]
{coderay}

The return value is a __placeholder__ for the final task. Let's explain that.

The Planning Pattern {#planning-pattern}
----------------
Generating plans can be a pretty expensive operation. This is why, in Roby, it
is done __asynchronously__ whenever possible.

Injecting new tasks-that-should-be-planned is a plan is done by actually adding
two tasks:

 * an instance of Roby::Task or of one of its subclasses which is a placeholder
   for the final task
 * a planning task, i.e. a Roby task that is the child of the placeholder in
   the planned_by relation. When using the standard Roby planning interface,
   the task used is Roby::PlanningTask .

There is an example of that pattern in action [in the
tutorial](../tutorial/relations_display.html#planning)

To make the pattern more obvious, one would like to have the placeholder task to be
of the right type, i.e. of the type that the method is going to return.

This can be done in the method definition by adding the :returns option:

{coderay:: ruby}
  method :move_to, :returns => MoveTo do
    target = arguments[:target]
    MoveTo.new(:target => target)
  end
{coderay}

Additionally, one can declare "some method" that users of a given planning
class will have to define (i.e. define generic methods and let the user define
the specific ones). This done by using Planner.method without a block:

{coderay:: ruby}
  method :move_to, :returns => MoveTo
{coderay}

