---
title: API Overview
sort_info: 400
---

= Overview

This page describes the various components that form a Roby application. It is
meant to be an "entry point" for people to understand what classes are there
for.

== Life and death of a Roby Controller

One Roby::Application instance is created per Roby controller. This class sets
up the various central objects (Roby::Plan, Roby::ExecutionEngine and Roby::DecisionControl, see
below), starts the execution engine and loads the relevant configuration files.

A Roby controller offers a DRb main server which is a Roby::Interface instance.
The best way to interact through this channel is to use a Roby::RemoteInterface
instance, which handles some custom marshalling/demarshalling of data, offering
a transparent interface to the remote controller. The <tt>scripts/shell</tt>
default script sets this up properly.

A Roby controller will shut down in the following conditions:
* CTRL+C is hit in the controller's main terminal
* the 'exit' command is sent through the remote shell
* a framework exception is detected, meaning an exception which is not part of
  the plan-based error recovery mechanism (everything but event commands, event
  handlers and polling blocks).

== Plan execution

The plan representation and the plan execution is handled by three objects:
* a Roby::Plan object which manages the various tasks and events which describe the
  system's plan.
* an Roby::ExecutionEngine object which manipulates that Roby::Plan object. It propagates
  events according to a set of "initial event", a set of events that are
  considered to be emitted. They can be generated by external communication (for
  instance from external robotic control frameworks like GenoM or Orocos), or
  internally by the scheduler object (see ExecutionEngine#scheduler). The engine
  is also responsible for reaction to errors and for the garbage collection
  mechanism, through which tasks that are useless for the system's goals are
  automatically killed and removed.
* a Roby::DecisionControl object which handles runtime error resolution (i.e.
  situations which require choosing between multiple course of action). For
  instance, if a signal leads to a task conflict -- i.e. if the signal would
  start a task which conflicts with another task -- the DecisionControl#conflict
  method is called. The default policy is to postpone starting the new task
  until all the conflicting tasks are stopped. Other policies could be to raise
  an error for instance.

The three "main" instances of these objects -- i.e. the ones that are supposed
to interact directly with the underlying robotic system -- are available
through the Roby.plan, Roby.engine and Roby.control attributes. These
attributes are set up at application start by Roby::Application#run (see below).
This is for an easy access in the main controller, but the architecture allows
to run multiple plans in parallel by binding those three different objects
yourself.

== A note about multi-robot systems

Until now, the Roby plan manager is able to run <b>bi-robot</b> plans, i.e.
plans where only two robots are interacting with each other. Extending that to
multi-robot is definitely on the TODO list of the project, but unfortunately it
will wait until multi-robot is back at the the center of my research. If you are
interested in doing it, of course, feel free to contact me ;-)

