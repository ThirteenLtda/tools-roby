---
title: TaskStructure::Dependency
sort_info: 100
--- name:content

Semantics
---------
The dependency relation defines that a task requires the result, or the
execution, of another task. If task t1 is a parent of task t2 in that relation,
it means that the successful execution of t1 requires the successful execution
of t2.

To add a new dependency relation between two tasks +t1+ and +t2+, simply do

{coderay:: ruby}
t1.depends_on t2
{coderay}

More specifically, the dependency relation expresses that +t2+ must achieve a
specific thing for +t1+. In Roby, such an achievement is of course defined by a
set of events.

So, in Roby terms, _depends\_on_ specifies that +t2+ should achieve a specific
thing for +t1+. By default, that achievement is the _success_ of the child task.
That can be changed through the +:success+ option of _depends\_on_. By default,
that set is <tt>:success</tt> (i.e. +t1+ requires a successful execution of
+t2+). As another example, the following

{coderay:: ruby}
t1.depends_on t2, :success => [:updated]
{coderay}

specifies that +t1+ needs +t2+ to emit its _updated_ event at least once. The
default is obviously equivalent to

{coderay:: ruby}
t1.depends_on t2, :success => [:success]
{coderay}

A different constraint that can be specified is that some events <b>should
not</b> be emitted. That is specified through the +:failure+ option. For
instance, if it is required that +t2+ does not stop while +t1+ is running, do

{coderay:: ruby}
t1.depends_on t2, :success => [], :failure => [:stop]
{coderay}

Both the :sucess and :failure options accept [event
predicates](../advanced_concepts/event_predicates.html) as values. Moreover, the
[unreachability](../advanced_concepts/unreachability.html) of all success events
is also an error (unless the success set is empty, of course). Therefore, the
default parameters of :success => [:success], :failure => [] both specify that
:success is a success event __and__ that :stop without :sucess is an error (as,
once :stop is emitted, :success becomes unreachable)

Runtime Behaviour
-----------------
The dependency relation does _not_ specify that +t2+ should run as long as +t1+
runs: to do that, you would need to specify that +t2+ must be started when +t1+
is started with (for instance):
  t1.should_start_after t2

However, both the [basic and temporal schedulers](../schedulers) use the
dependency relation to order the start of tasks. In both these schedulers, if no
other constraints apply, a task can only be scheduled if one of its parent has
been started.

The relation constraint is one-shot: if the success predicate is true, the
relation is ignored for the rest of the execution.
For instance, if the following relation is added:

{coderay:: ruby}
t1.depends_on t2, :success => [:updated], :failure => [:success]
{coderay}

Then as soon as +:updated+ is emitted, the emission of +:success+ is not a
failure anymore. In a same way, as soon as +:success+ is emitted then the
emission of +:updated+ will not be considered as a success anymore. If both
events are emitted in the same cycle, the success event takes precedence.

Common Use-Cases
----------------

The most common use case is the default dependency relation behaviour: success
is [:success] and failure is empty.



== Manipulation
A dependency relation is added with the #depends_on call. Apart from the
+:success+ and +:failure+ options described above, one other option is
available: the +:remove_when_done+ option. If set to true, as for instance
  t1.depends_on t2, :remove_when_done => true

then the relation is automatically removed as soon as it is not useful anymore
(i.e. one of the success events is emitted).

A dependency relation is removed with #remove_child
  t1.remove_child t2

Children are enumerated with
  t1.each_child { |t2, options| ... }
  t1.children => enumerator

and parents with
  t2.each_parent { |t1| ... }
  t2.parents => enumerator

Moreover, dependency relationship between two tasks can be tested with the
following predicates:
  t2.depended_upon_by?(t1)
returns true if t2 is a dependency of t1: t2 is a direct child of t1.
  t1.depends_on?(t2)
returns true if t1 depends on t2 in one way or the other, i.e. that t2 is a
child or a grandchild or a grand-grandchild or ... of t1.
  t1.depends_on?(t2, false)
returns true if t1 directly depends on t2: t1 is a direct parent of t2.

== Errors

The two types of errors that can occur in the context of a dependency relation
are:
* no success event will ever be emitted
* one of the failure events is emitted

In both cases, a {rdoc_class: ChildFailedError} exception is generated. In the
first case, the failure point is the success event generator that is
unreachable. In the second case, it is the event that triggered the failure.

