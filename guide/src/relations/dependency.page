---
title: TaskStructure::Dependency
sort_info: 100
--- name:content pipeline:tags,rdoc,blocks

== Semantics
The dependency relation is is a <i>dependency</i> relation. If task t1 is a
parent of task t2 in that relation, it means that the successful execution of
t1 requires the successful execution of t2.

To add a new dependency relation between two tasks +t1+ and +t2+, simply do
  t1.depends_on t2

More specifically, the dependency relation expresses that +t2+ must achieve a
specific thing for +t1+. In Roby, such an achievement is of course defined by a
set of events.

So, in Roby terms, _depends\_on_ specifies that +t2+ should achieve a specific
thing for +t1+. By default, that achievement is the _success_ of the child task.
That can be changed through the +:success+ option of _depends\_on_. By default,
that set is <tt>:success</tt> (i.e. +t1+ requires a successful execution of
+t2+). As another example, the following
  t1.depends_on t2, :success => [:updated]

specifies that +t1+ needs +t2+ to emit its _updated_ event at least once. The
default is obviously equivalent to
  t1.depends_on t2, :success => [:success]

A different constraint that can be specified is that some events <b>should
not</b> be emitted. That is specified through the +:failure+ option. For
instance, if it is required that +t2+ does not stop while +t1+ is running, do
  t1.depends_on t2, :success => [], :failure => [:stop]

Note that it does _not_ specify that +t2+ should run as long as +t1+ runs: to do
that, you would need to specify that +t2+ must be started when +t1+ is started
with (for instance):
  t1.on :start, t2, :start

The relation constraint is one-shot: if any of the success events have already
been emitted, then the failure events do not matter anymore. For instance, if
the following relation is added:
  t1.depends_on t2, :success => [:updated], :failure => [:success]

Then as soon as +:updated+ is emitted, the emission of +:success+ is not a
failure anymore. In a same way, as soon as +:success+ is emitted then the
emission of +:updated+ will not be considered as a success anymore.

== Manipulation
A dependency relation is added with the #depends_on call. Apart from the
+:success+ and +:failure+ options described above, one other option is
available: the +:remove_when_done+ option. If set to true, as for instance
  t1.depends_on t2, :remove_when_done => true

then the relation is automatically removed as soon as it is not useful anymore
(i.e. one of the success events is emitted).

A dependency relation is removed with #remove_child
  t1.remove_child t2

Children are enumerated with
  t1.each_child { |t2, options| ... }
  t1.children => enumerator

and parents with
  t2.each_parent { |t1| ... }
  t2.parents => enumerator

Moreover, dependency relationship between two tasks can be tested with the
following predicates:
  t2.depended_upon_by?(t1)
returns true if t2 is a dependency of t1: t2 is a direct child of t1.
  t1.depends_on?(t2)
returns true if t1 depends on t2 in one way or the other, i.e. that t2 is a
child or a grandchild or a grand-grandchild or ... of t1.
  t1.depends_on?(t2, false)
returns true if t1 directly depends on t2: t1 is a direct parent of t2.

== Errors

The two types of errors that can occur in the context of a dependency relation
are:
* no success event will ever be emitted (see event
  unreachability:"/objects/events")
* one of the failure events is emitted

In both cases, a {rdoc_class: ChildFailedError} exception is generated. In the
first case, the failure point is the success event generator that is
unreachable. In the second case, it is the event that triggered the failure.

