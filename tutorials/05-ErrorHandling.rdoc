{Previous tutorial}[link:files/doc/tutorials/04-EventPropagation_rdoc.html]
= Representing and handling errors

One thing about robotics, and in particular plan execution, is that Murphy's
rule applies quite well. This is due to a few things. Among them, the first is
that the models planning uses (and therefore the plans it builds) are (i) too
simple to completely reflect the reality, (ii) badly parametrized and (iii)
represent dynamic agents, which can themselves be able to take decisions. So, in
essence, the rule of thumb is that a plan will fail during its execution.

Because Roby represents and executes all the activities of a given system, the
representation of errors becomes a very powerful thing: it is quite easy, when
an error appears somewhere to actually determine what are its consequences.

What this tutorial will show is:
* how parts of the error conditions are encoded in the task structure.
* how exceptions that come from the code itself (like NoMethodError ...) are
  handled.

== Where do errors come from ?
=== Task structure as a constraint representation

Some (not all) task relations also define a set of constraints on the plan
execution. For instance, the +realized_by+ relation defines a set of
_desirable_ and a set of _forbidden_ events (the +success+ and +failure+
options of TaskStructure#realized_by). If none of the desirable events are
reachable (i.e. none will be emitted +ever+, see
Roby::EventGenerator#unreachable?), or if one of the forbidden events is
emitted, a ChildFailedError error is generated.

For instance, if we look at the first tutorial, we had an error provoked because
the +failed+ event of ComputePath has been emitted, while ComputePath was a
child of MoveTo:
  $ scripts/shell
  >> move_to! :x => 10, :y => 10
  => MoveTo{goal => Vector3D(x=10.000000,y=10.000000,z=0.000000)}:0x48350370[]
  >>
  !Roby::ChildFailedError
  !at [336040:01:45.419/186] in the failed event of ComputePath:0x483502e0
  !block not supplied (ArgumentError)
  !  /home/doudou/dev/roby/lib/roby/thread_task.rb:51:in `instance_eval',
  !    /home/doudou/dev/roby/lib/roby/thread_task.rb:61:in `value',
  !    /home/doudou/dev/roby/lib/roby/thread_task.rb:61:in the polling handler,
  !    /home/doudou/system/powerpc-linux/ruby-1.8.6/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:27:in
`gem_original_require',
  !    /home/doudou/system/powerpc-linux/ruby-1.8.6/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:27:in `require',
  !    scripts/run:3
  !
  !The failed relation is
  !  MoveTo:0x48350370
  !    owners: Roby::Distributed
  !    arguments: {:goal=>Vector3D(x=10.000000,y=10.000000,z=0.000000)}
  !  realized_by ComputePath:0x483502e0
  !    owners: Roby::Distributed
  !    arguments: {:max_speed=>1.0,
  !     :goal=>Vector3D(x=10.000000,y=10.000000,z=0.000000)}
  !The following tasks have been killed:
  !  ComputePath:0x483502e0
  !  MoveTo:0x48350370

In the case of the PlannedBy relation that we saw in the previous tutorial, the
error is that no plan can be found. A PlanningFailedError is generated in that
case.

Those two types of error have in common that it is possible to associate the
error with one of the plan objects (event or task). They are <i>localized
errors</i> and are subclasses of Roby::LocalizedError. The nice aspect of that
is that it is possible to assess what is their impact on the plan execution. It
is therefore possible to handle the error at the plan level and continue
executing what can be executed.

=== Errors generated by the code itself

In that case, the problem is not to have plan-specific errors anymore. It is to
handle errors that appear because of bugs in the code itself. Roby is
implemented in a way where the code is split into two parts:

The <i>framework code</i> is the really problematic one. It means that there is
really a bug in the execution engine itself. In that case, Roby tries to hang up
as cleanly as possible by killing all tasks that are being executed.

The <i>user code</i> is the part of the code which is tied to events and tasks:
event commands, event handlers, polling blocks. For those, it is actually
possible to generate a Roby::LocalizedError as in the previous case and to
handle the error at the plan level. Failed command tasks generate a
Roby::CommandFailedError, failed event handlers a Roby::EventHandlerError.
Polling blocks actually emit +failed+ with the poller exception as context (see
the above error message).

Let's try. Add the following event handler in the definition of MoveTo
(<tt>tasks/move_to.rb</tt>).

  on :start do
    raise
  end

Start (or restart) the controller and launch a <tt>move_to!</tt> action in the
shell. The following should happen:

  !Roby::EventHandlerError: user code raised an exception at [336641:28:04.607/23] in the start event of MoveTo:0x2b4330b4fae8
  !
  !
  ! (RuntimeError)
  !./tasks/move_to.rb:10:in event handler for 'start',
  !  /home/joyeux/system/rubygems/lib/rubygems/custom_require.rb:27:in `gem_original_require',
  !  /home/joyeux/system/rubygems/lib/rubygems/custom_require.rb:27:in `require',
  !  scripts/run:3
  !The following tasks have been killed:
  !  MoveTo:0x2b4330b4fae8

An equivalent thing would happen with a task-level event handler (i.e. one
defined on the task object instead of the task model). Try adding

  move.on :start do
    raise
  end

to the planning method in <tt>planners/PathPlan/main.rb</tt>.

What we can see in the relation display is the following two successive steps
(don't forget to uncheck <tt>View/Hide finalized</tt>).

link:../images/replay_handler_error_0.png
link:../images/replay_handler_error_1.png

From Roby point of view, the event has already happened when the event handlers
are called. Therefore, the event propagation should go on (the temporal
structure is well-formed). However, an error occured and has not been handled,
so the MoveTo task cannot be kept running. That is the job of the garbage
collection process, which queues the 'stop' event, to be executed during the
next cycle. The MoveTo task is therefore stopped at the next cycle, and the
tasks that are now useless are also stopped.

